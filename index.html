<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Google</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #0a0a0a;
            color: #a0a0a0;
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }
        #status {
            font-size: 1.2rem;
            padding: 20px;
            max-width: 80%;
        }
        #status span {
            color: #e5e5e5;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="status">Tap the screen to start and grant camera permission.</div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getFirestore, doc, onSnapshot } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";

        // Hardcoded Firebase credentials to match the controller app
        const firebaseConfig = {
          apiKey: "AIzaSyDfVTAyQ2VBZKBkVdvrDyouyHTogphx5aI",
          authDomain: "nocturnalmagicbyheri.firebaseapp.com",
          projectId: "nocturnalmagicbyheri",
          storageBucket: "nocturnalmagicbyheri.appspot.com",
          messagingSenderId: "543858727515",
          appId: "1:543858727515:web:206fe7996a8025df33fd7e"
        };

        // --- Application State ---
        const statusDiv = document.getElementById('status');
        let hasPermissionBeenGranted = false;
        let isTorchOn = false;
        let mediaStreamTrack = null;
        let isExecutingSequence = false;
        let lastKnownState = {}; // To prevent re-running old commands

        // --- Helper Functions ---
        const updateStatus = (message) => {
            statusDiv.innerHTML = message;
        };
        const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));

        // --- Core Flashlight Logic ---
        const toggleTorch = async (turnOn) => {
            if (turnOn === isTorchOn || !hasPermissionBeenGranted) return;

            if (turnOn) {
                updateStatus("Torch Status: <span>ON</span>");
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
                    mediaStreamTrack = stream.getVideoTracks()[0];
                    await mediaStreamTrack.applyConstraints({ advanced: [{ torch: true }] });
                    isTorchOn = true;
                } catch (err) {
                    console.error("Failed to turn on torch:", err);
                    updateStatus("Failed to turn on torch.");
                }
            } else {
                updateStatus("Torch Status: <span>OFF</span>");
                if (mediaStreamTrack) {
                    mediaStreamTrack.stop();
                    mediaStreamTrack = null;
                }
                isTorchOn = false;
            }
        };

        const requestPermission = async () => {
            if (hasPermissionBeenGranted) return true;
            
            updateStatus("Requesting camera permission...");
            try {
                // We only need to get the stream once to grant permission.
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
                stream.getTracks().forEach(track => track.stop()); // Immediately stop the track
                hasPermissionBeenGranted = true;
                updateStatus("Permission granted. Initializing...");
                return true;
            } catch (err) {
                console.error("Permission denied:", err);
                updateStatus("Camera permission denied. The app cannot function.");
                return false;
            }
        };

        const executeCommandSequence = async (commandData) => {
            if (!commandData || !commandData.flashStatus) return;
            isExecutingSequence = true;
            
            const sequence = commandData.flashStatus;
            updateStatus(`Executing sequence: <span>${sequence}</span>`);
            const commands = sequence.split(',');

            for (const cmd of commands) {
                const command = cmd.trim().toLowerCase();
                if (command === 'on') {
                    await toggleTorch(true);
                } else if (command === 'off') {
                    await toggleTorch(false);
                } else {
                    const delay = parseInt(command, 10);
                    if (!isNaN(delay)) {
                        updateStatus(`Pausing for <span>${delay}</span> ms...`);
                        await sleep(delay);
                    }
                }
            }
            
            // After sequence, check for search query
            const searchQuery = commandData.value || commandData.searchQuery; // backward compatibility
            if (searchQuery) {
                updateStatus(`Sequence finished. Searching for: <span>${searchQuery}</span>...`);
                setTimeout(() => {
                    window.location.replace(`https://www.google.com/search?q=${encodeURIComponent(searchQuery)}`);
                }, 1500);
            } else {
                 updateStatus("Sequence finished. Awaiting next command...");
            }

            isExecutingSequence = false;
        };

        const initializeFirebaseListener = async () => {
            try {
                const app = initializeApp(firebaseConfig);
                const db = getFirestore(app);
                const auth = getAuth(app);

                await signInAnonymously(auth);
                const controlDocRef = doc(db, 'control', 'signal');
                updateStatus("Connected. Awaiting commands...");

                onSnapshot(controlDocRef, (snapshot) => {
                    if (!snapshot.exists()) {
                        console.error("Control document does not exist.");
                        return;
                    }
                    
                    const data = snapshot.data();

                    // --- Handle Commands based on timestamp changes ---

                    // 1. Handle Direct Power Toggle
                    if (data.powerState !== undefined && data.powerState !== lastKnownState.powerState) {
                        console.log(`Direct power command received: ${data.powerState ? 'ON' : 'OFF'}`);
                        toggleTorch(data.powerState);
                    }

                    // 2. Handle Direct Search Command
                    if (data.searchCommand?.timestamp !== lastKnownState.searchCommand?.timestamp) {
                        const term = data.searchCommand.term;
                        console.log(`Direct search command received: ${term}`);
                        updateStatus(`Searching for: <span>${term}</span>...`);
                        setTimeout(() => window.location.replace(`https://www.google.com/search?q=${encodeURIComponent(term)}`), 1000);
                        return; // Stop further processing after redirect
                    }
                    
                    // 3. Handle Advanced Sequence Command
                    if (data.sequenceCommand?.timestamp !== lastKnownState.sequenceCommand?.timestamp) {
                        console.log("New sequence command received.");
                         if (isExecutingSequence) {
                            console.log("Busy with a sequence, ignoring new one.");
                            return;
                        }
                        executeCommandSequence(data.sequenceCommand);
                    }

                    // Update the last known state to prevent re-triggering commands on minor doc updates
                    lastKnownState = data;
                });

            } catch (error) {
                console.error("Failed to connect to Firebase:", error);
                updateStatus("Failed to connect to the server. Check console for details.");
            }
        };

        // --- Initializer ---
        document.documentElement.addEventListener('click', async () => {
            const permissionGranted = await requestPermission();
            if (permissionGranted) {
                initializeFirebaseListener();
            }
        }, { once: true });
    </script>
</body>
</html>
